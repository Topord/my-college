## 哈夫曼编码

### 任务一：求解每个符号的哈夫曼编码

#### 	一、主要目的

求出每个符号所对应的哈夫曼编码，以文件的形式展示出来。

#### 	二、主要思路

借助所求的每个符号的权重，再加上求解哈夫曼编码的算法求解。

#### 	三、逻辑框图

- ![1656774287057.png](https://img1.imgtp.com/2022/07/02/R6fWhb2e.png)

#### 	四、主要代码部分

```c
void Create_HufCode(WordPointer head,char **huf, int num, FILE* w)	
{
	int i;			
    int sit;	
    int pp;		
    int c;			
//求解编码
    char *tmp = (char *)malloc(num * sizeof(char));
    WordPointer h = head;
    tmp[num-1] = '\0';				
    for(i = 0; i < num; i++)	
    {
        sit = num - 1;		
        for(c = i, pp = head[i].parent; pp != -1; c =pp, pp= head[pp].parent)
        {
            if( head[pp].lchild == c)
				tmp[--sit] = '0';  
            else
                tmp[--sit] = '1'; 
        }
        huf[i] = (char *)malloc((num - sit) * sizeof(char));
        strcpy(huf[i], &tmp[sit]);
//写入文件
        //写字符
		if(h->fst >= 224){
        	if(h->fst == 238){
            	fprintf(w, "%d/%d/%d" , h->fst, h->scd, h->thd);
        	}
        	else{
            	fputc(h->fst, w);
            	fputc(h->scd, w);
            	fputc(h->thd, w);
        	}
   		 }
   		 //单字节的（包含\n、空格）
    	else{
        	if(h->fst == 10){
            	fprintf(w, "\\n");
        	}
        	else{
            	fputc(h->fst, w);
        	}
    	}
        //写对应的编码
    	fprintf(w, "\t%s\n", huf[i]);
		h++;
	}
        free(tmp);		
}
```

### 任务二：根据编码加密文件

#### 	一、主要目的

根据每个字符的编码加密文本文件，并将加密文件输出。

#### 	二、主要思路

对需要加密的文件进行读取，将读取的内容与数组中每个元素的编码进行比较，相同则在文件中写入这个元素的所对应的哈夫曼编码；不相同则与下一个元素的编码进行比较。

#### 	三、逻辑框图

 ![1656775481061.png](https://img1.imgtp.com/2022/07/02/3VFJ9N3z.png) 

#### 	四、遇见的问题

##### 			1. 所求的文件大小远远大于原文件

![1656777470951](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\1656777470951.png)

```c
void Enfile(FILE* read, FILE* write, WordPointer p) //加密文件
{
	unsigned char a, b, c;
	char str;
	WordPointer h;
	h = p;
	
	str = fgetc(read);
	
	while(a != EOF){  //问题
        a = str;
        // 三个字节的编码
        if(a >= 224){
            b = fgetc(read);
            c = fgetc(read);
            Write(a, b, c, h, write);
        }
        // 单个字节
        else{
            b = c = 0;
            Write(a, b, c, h, write);
        }
     	str = fgetc(read);   
    }	
	fclose(read);
	fclose(write);
}
void Write(unsigned char s1, unsigned char s2, unsigned char s3, WordPointer head, FILE* write)
{
	int i = 0;
	WordPointer sp;
	sp = head;
	while(i < 4005){
		if(s1 == sp->fst && s2 == sp->scd && s3 == sp->thd){
			fprintf(write, "%s", sp->rst);
            break;
        }
        sp++; 
        i++;
    }
} 
```

原因：边界条件没有设置好、没有用二进制写入

当把“%s”换成"%d"时，文件会更小

### 任务三：解码

#### 	一、思路

一个个读取加密文件中的‘0’和‘1’，在程序中组合成字符串，将所得字符串与链表中各个元素的哈夫曼编码部分进行比较，若是相等，则将该编码的字符写入文件中;若不相等，则读取下一个直至相等。

```c
void Defile(FILE* read, FILE* write, WordPointer p)
{
	WordPointer h = p;
	read = fopen("加密文件.txt", "r");
	write = fopen("解密文件.txt", "w");
	int i = 0, j = 0;
	unsigned char str, a, b, c;
	unsigned char s[20] = {0};
	str = fgetc(read);
	while(str != EOF){
        a = str;
		s[i] = a;         //有问题
		while(j < 4005)
		{
			if((strcmp(s, h->rst)+1)){ //相等为0
				fputc(h->fst, write);
                fputc(h->scd, write);
                fputc(h->thd, write);
				i = 0;
				break;
			}
			if(j == 4004){
				i++;
				j = 0;
				break;
			}
			h++;
		} 
		h = p;
		str = fgetc(read);
    }	
    fclose(write);
    fclose(read);
}
```


### 表达式任务求值会议总结

### 一、任务一（将2345（10）转换成7进制的数）

该任务主要思想为将十进制整数转换成X进制整数采用“除X取倒余法”。即将十进制整数除以X，得到一个商和一个余数；再将商除以X，又得到一个商和一个余数；以此类推，直到商等于零为止。每次得到的余数的倒排列，就是对应X进制数的各位数。于是，结果是余数的倒排列，即为结果。此处拿2345(10)转七进制为列子。

```c
shang = num / N;
yushu = num % N;
Push(ps, yushu);	

while(shang != 0){
    yushu = shang % N;
    shang = shang / N;
    Push(ps, yushu);
}
//Push函数为入栈函数，shang--商、yushu--余数
```

### 二、任务二（表达式转为后缀表达式）

#### 1. 主要思想与逻辑

从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止。 

![image-20220417160813241](https://gitee.com/buguai_lxw/key/raw/master/202204171608303.png)

#### 2. 一些常见的问题以及可以使用的函数

##### (1). 多位数字的入栈

因为遍历字符串的时候是一个个遍历的，所以遇见如12+12的时候，我们需要将第一个入栈的数字1和第二个入栈的数字2合并成12再重新入栈。(下面的代码是指针对于表达式的字符部分)

```C
for (i = 0; in[i] != '\0'; i++){							//读字符串 
		if (in[i] >= '0' && in[i] <= '9'){						//数字 
			temp = in[i] - '0';									//将字符转换为数值 
			while (in[i + 1] != '\0'){           				//多位数值获取
				if (in[i + 1] >= '0' && in[i + 1] <= '9'){
					temp = temp * 10 + in[i + 1] - '0';			
					i++;
				}else
					break;										//读到符号 
			}		
			PushNum(p1, temp);										//入栈 
		}
```

##### (2). 输出时"%s"和"%c"的区别

%s 格式输出 字符串， printf(“%s”，ch）；它从 ch 的 首地址里的字符开始输出。输完，输ch 地址加1地址里的字符，一直输出到==遇到字符串结束符 '\0'== 时输出才停止。
		char类型的单个字符存储内部不含结束符。按%s输出时，地址一直增加，又找不到字符串结束符 '\0'， 所以程序会崩溃。如果 char ch[]="a"; 则 printf(“%s”，ch）；就正确了。双引号括起的是字符串常量，含字符串结束符 '\0'.

```c
//大家可以试一下
char str[50];
printf("请输入中缀表达式：\n");	
gets(str); 
printf("%s",str[0]);
printf("%c",str[0]);
```

##### (3). isdigit（）函数

头文件：#include <ctype.h>

定义函数：int isdigit(int c);

函数说明：检查参数 c 是否为阿拉伯数字0 到9。

返回值：若参数c 为阿拉伯数字，则返回true，否则返回null(0)。一般用在条件判断中。

举例：找出str 字符串中为阿拉伯数字的字符。

```c
#include <ctype.h>
main(){    
char str[] = "123@#FDsP[e?";//给出一个字符串    
int i;    
for(i = 0; str[i] != 0; i++)//遍历  
	if(isdigit(str[i]))//判断            
		printf("%c is an digit character\n", str[i]);//输出
}
```

执行结果：
			1 is an digit character
			2 is an digit character
			3 is an digit character

### 三、任务三（后缀表达式求值）

### 1. 主要逻辑

![image-20220417170018069](https://gitee.com/buguai_lxw/key/raw/master/202204171700134.png)



### 2.注意事项

#### (1). 字符串储存问题

​		中缀表达式可能求取的时候20个空就够了，但是后缀表达式可能就不够了，存不下就可能导致后面出问题。**所以定义数组存东西的时候要定义大一点。**

一开始我定义的char数组就有20个空，存后缀表达式只能存20个嘛，第二十一个是减号，显然存不进去，那么我去读取这个没有的值就出错了，甚至出现了同一个i读取结果不同的现象。**感觉很玄学，还是写规范的好，规范=没有bug。**

同一个i，一个<,一个(

不过这里可能不同编译器结果就不同,可能别的编译器里会自动扩充什么的，那样运行结果就是对的。

#### (2). 数字还原问题

**第一种方法**

```c
 while(isdigit(str[i])!=0 )
 {
           number=number*10+str[i]-'0';
     		//数字对应的ASCII码-'0'正好是对应的数字本身 
           i++;
           if(isdigit(str[i])==0)
           //如果下一个不是数字那么就把前面得到的数字入栈，然后进行下一步 
			{
				Push(ps,number);//入栈
				break;	
			}
}
```

因为要进行计算，所以数字读取的时候需要整个读取出来，我想了两种不过只用了一种。

读取数字利用的ASCII码的关系---> ‘9’-‘0’=9.

同样可以使用isdigit(str[i])函数去判断当前字符是不是数字。

**第二种方法**

```c
 while(isdigit(str[i])!=0 )//如果这个数是十进制数字，直接输出 ;如果是数字此函数返回非0值，否则返回0
	   {
		   number = atoi(str);//用这个函数能直接获取数字，但是只能是开头就是数字的，以非数字字符结尾 ---但是这个每次取完数字都需要把数字从数组里删除，比较麻烦 
		   //这里通过上面获取数字，用这个来计数，然后从数组里删除这几个数字 
		   flag=Count(number);//获取数字的长度 
		   printf("%d",number);
		   Push(ps,number);//把数字入栈
		   i=i+flag;
           i++;
           if(isdigit(str[i])==0)//如果下一个不是数字那么就把前面得到的数字入栈，然后进行下一步 
				{
					Push(ps,number);//入栈
					break;	
				}

	   }
```

在#include<stdlib.h>这个头文件里有个atoi()函数能够直接获取数字。

【函数说明】atoi() 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时('\0')才结束转换，并将结果返回。

【返回值】返回转换后的整型数；如果 str 不能转换成 int 或者 str 为空字符串，那么将返回 0。

我想的就是通过这个函数把数字获取出来，然后再去运算。一开始读取进来的表达式存在数组里了，所以每次读取数字完毕后需要读取这个数字的位数，把这个数字从字符串数字里删掉。比上面那个方法麻烦。

### 四、 任务四（中缀表达式求值）

#### 1、基本逻辑。

1. 操作数，直接入数字栈；

2. 栈为空时，遇到运算符，入符号栈；

3. 遇到左括号，将其入符号栈；

4. 遇到右括号，执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出；

5. 遇到其他运算符’+”-”*”/’时，弹出所有优先级大于或等于该运算符的栈顶元素并进行运算，将结果压入数字栈，然后将该运算符入栈；

6. 最终将栈中的元素依次出栈，输出。

#### 2、逻辑图

####  ![未命名-3.png](https://img3.imgtp.com/2022/04/17/625bb7921f20a.png)  



 ![未命名-4.png](https://img3.imgtp.com/2022/04/17/625bba565b27e.png)

#### 3、新想法

```C
//在比较符号优先级时，可以用二维数组进行判断
char  seek[7][7] = {
				  {'>','>','<','<','<','>','>'},    /*用来进行比较运算符优先级的矩阵*/
				  {'>','>','<','<','<','>','>'},
				  {'>','>','>','>','<','>','>'},
				  {'>','>','>','>','<','>','>'},
				  {'<','<','<','<','<','=',' '},
				  {'>','>','>','>',' ','>','>'},
				  {'<','<','<','<','<',' ','='}
};
```

```C
char Precede(char ch1, char ch2) //比较运算符优先级 
{
	int i=0, m=0, n=0;
	char p;
	for (i = 0; i < 7; i++)  //找出两个数的位置 
	{
		if (optr[i] == ch1)
			m = i;
		if (optr[i] == ch2)
			n = i;
	}
	p = seek[m][n];   //找到比较结果
	return p;
}
```


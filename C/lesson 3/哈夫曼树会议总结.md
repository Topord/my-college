# 哈夫曼树会议总结

## 1.主要思路

建立四个结点--->初始化哈夫曼树--->找最小值和次小值--->重新赋值给四个结点--->显示结果

## 2.流程图

![img](.\image1\[W}0@FPJ_RNOS$_XAE5WX.png)

## 3.方法总结

### <1>找最小值和次小值（重难点）

**思路**：获取最小值和次小值的下标，通过指针与下标去访问数值。

**三种方法**：

**第一种**

找一个很大的值（确保比权重值大就行，搞个10000，正常的权值不会超过一万），去和孤结点的权重值去比较，每次比较后把较小的值赋值给原先值为10000的变量，同时获取较小值的下标值，以此类推，肯定可以找到最小值。

**说明**：次小值的思路和这个相同，只不过在利用for循环的时候下标值要排除最小值的下标。

![img](.\image1\PC%V]95_1[@_D1ARZ]XN`F.png)

**第二种**

获取最前面两个孤结点中的较大值，同时获取两个孤结点中的较大值的下标。这样就能保证在寻找最小值和次小值的循环里排除最小值和次小值下标获取不到的情况（就算在寻找最小值和次小值的比较中没有得到这个值也没关系，因为前面最小值和次小值下标值已经获取）。

![image-20220424220056238](.\image1\image-20220424220056238.png)

**第三种**

四次遍历法：

- 第一次：找出所有节点中，第一个无父节点的下标给\*min_1。
- 第二次：比较\*min_1，找出最小的无父节点的下标给\*min_1并标记。
- 第三次：找出所有节点中，第一个无父节点的权重和下标给\*min_2。
- 第四次：比较\*min_2，找出最小且未标记的无父节点的下标给\*min_2。

**访问数值：**

![image-20220425122556771](.\image1\image-20220425122556771.png)

前面获取到最大值和最小值的下标后，通过指针和下标就能访问数值。

如该图中，ps[*s1*].parent就是去访问最小值的父结点。

### <2>关于度的概念以及结点总数为2n-1的证明

![image-20220424221142532](.\image1\image-20220424221142532.png)

**度**：当前结点有几个分支，度就是几（二叉树嘛，最多两个分支）。

由于ni表示度为i的结点数，那么n0就是分支为0的结点，n1就是分支为1的结点，n2就是分支为2的结点，这样算，边的总和就是0xn0+1xn1+2xn2

两个结点构成一个边，所以边的条数就是结点数-1，也就是n0+n1+n2-1

所以根据关系就能推出来n2=n0-1

最后构建好的树只有分支为0和分支为2的结点，也就是n0+n2，也就是2n0-1。

**注意：二叉树里有一个分支的结点，前面的结论是根据二叉树推得的。哈夫曼树也是二叉树的一种---最优二叉树嘛。**

### <3>数组的两种形式

**①类型名* 数组名**

​	比如 int *w  ---w是某个数组名

**②类型名 数组名[]**

​	比如 int w[] ---w是某个数组名

### <4>改变数值的两种方法

**①指针**

![image-20220425123921458](.\image1\image-20220425123921458.png)

​		![image-20220425123903580](.\image1\image-20220425123903580.png)

上面是定义函数时的题头，下面是使用函数的情形。

其中s1、s2是我们想改变的值，使用函数时把想改变的地址传递过去，在函数定义部分使用int *s1接收，那么在这个函数里对s1进行操作，s1的值也会改变。

**②取别名&**

![image-20220425124221303](.\image1\image-20220425124221303.png)

在定义函数的时候直接用int &n1，其中n1是想改变的值，在这个函数里对s1进行操作，s1的值也会改变。作用和指针作用是一样的，这个用法是C++里的，C语言这个也可以用。

### <5>数组传递时下标对应两种方法

使用数组存储所有孤结点，然后再从该数组中获取最大值和最小值。但是这样会出现数组中的孤结点下标值和哈夫曼树里的下标值不对应问题。

所以有两种解决办法：

**①分两个一维数组存储**，一个数组存储权重值，另一个数组存储对应的下标

**②一个二维数组存储**，把权重值和下标值作为一个元素存储。

### <4>输出形式---更贴合手画效果

![](https://gitee.com/buguai_lxw/key/raw/master/202204240954478.png)

从上往下看，左下方的值是左儿子，右下方的值是儿子。依次往下，比较符合手画的效果。

**实现：**

①先用递归把树的权重放入数组中

②先得到最高节点，也就是唯一一个父节点为0的节点，然后再得到该节点的左深度,用于把这个节点放在数组中适合的位置，再得到最大的深度，用于创建数组，再把数组初始化为0

再调用tree update树

再打印出来

### <5>sizeof确定数组个数

![image-20220425130301767](.\image1\image-20220425130301767.png)

这里利用内存来确定数组内元素个数---sizeof(node)/sizeof(node[0])就是元素个数。数组内总内存/数组单个元素内存就是有几个元素

### <6>传递结点个数浮动两种方法

**①以0为限制条件**

由于未经运算的结点初值为0，所以在运行时，可以设置结点权重为0当限制条件，也就是限制了后面找最小值和次小值的循环次数。

![image-20220425131002395](.\image1\image-20220425131002395.png)

**②传递可变参数**

![image-20220425131341428](.\image1\image-20220425131341428.png)

i是不断变化的，下面select函数中传递的参数i-1就是变化的，实现和第一种方法相同效果。

## 4.注意点

### <1>注意所有排序的结点都需要是孤结点---没有父结点的结点为孤结点

### <2>根据需要选择动态变量

需要两个变量就需要开辟两个空间，并把两个空间的首地址分别赋值给两个不同的变量。

### <3>break只能跳出一个循环

跳出多个循环就需要多个break

### <4>指针取值形式

(ps+k)->parent和ps[k].parent的效果是一样的，其中ps是指针名字，k是下标


### 构造哈夫曼树(链表)

#### 一、主要目的

1. 根据输入的5个数构造出一颗哈夫曼树（用数组实现）；
2. 将每个节点的父节点、左右孩子和权重打印出来。

#### 二、实现主要逻辑

##### 1. 文字描述

1. 开辟空间：首先创建2*N-1个节点（即开辟2*N-1个大小为每个节点大小的空间）；

2. 赋初始值：将N个节点的数据输入并将其余的节点的权重赋值0，然后将所有节点的父节点、左孩子和右孩子的值全部赋值-1；

3. 进行比较并返回对应数值：

   - 找最小值：将节点的首个权重与父节点为-1的节点的权重进行比较，找出最小的权重；
   - 存储数值：将最小值和节点位置存储在两个数组当中；
   - 找次小值：将节点的首个权重与父节点为-1的节点的权重且不等于最小值进行比较，找出最小的权重；如果次小值=最小值，那么同样存储；

   ==注==：当进行到只有最后两个数的时候，直接将剩下的节点权重相加，就不进行比较；

4. 数据装进节点；

5. 将结果打印出来。







##### 2. 图片形式

- ![未命名-5.png](https://img1.imgtp.com/2022/04/24/IiHKi7bX.png)



- ![Untitled1.png](https://img1.imgtp.com/2022/04/24/IkOmObYg.png)

  

#### 三、 函数

##### 1.  初始化

```c
void Init_Node(Pointer p, int* arr, int len1, int len2)
{
	int i;
	for(i = 0; i < len1; i++){
		if(i <= len2){
			p->weight = *arr;
			p->parent = -1;
			p->left = -1;
			p->right = -1;
			p++;
			arr++;
		}else{
			p->weight = 0;
			p->parent = -1;
			p->left = -1;
			p->right = -1;
			p++;
		}
	}
}
```

##### 2. 比较

```c
void Sort(Pointer p, Uint* x, Uint* y, int len, int m)
{
	Pointer q = p;
	int i, t;
	*x = 0;
	*(x + 1) = 0;
	*y = 0;
	*(y + 1) = 0;
	t = p->weight; 
	for(i = 1; i <= len; i++){
		if((p+1)->parent == -1){
			if(t > (p+1)->weight && t != 0 && (p+1)->weight != 0){
				t = (p+1)->weight;
				*y = i;
			}
		}
		p++;
	}
	*x = t;
	p = q;
	t = p->weight;
	for(i = 1; i <= len; i++){
		if((p+1)->parent == -1){
			if(t > (p+1)->weight && t != 0 && (p+1)->weight != 0 && (p+1)->weight != *x){
				t = (p+1)->weight;
				*(y + 1) = i;
			}
		}
		p++;
	}
	p = q;
	*(x + 1) = t;
	if(*x == *(x + 1) && m == 8){            //最后一个节点 
		*(x + 1) = (p+7)->weight; 
		*(y + 1) = 7;
	}
}
```

